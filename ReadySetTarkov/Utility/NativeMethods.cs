using System;
using System.Collections.Generic;
using System.Threading.Tasks;

using Microsoft.Extensions.Logging;
using Microsoft.VisualStudio.Threading;

using Windows.Win32;
using Windows.Win32.Foundation;

namespace ReadySetTarkov.Utility;

/// <summary>
/// PInvoke area. See NativeMethods.txt for methods that are being generated by CsWin32.
/// </summary>
internal class NativeMethods : INativeMethods
{
    public NativeMethods(ILogger<NativeMethods> logger, IKernel32 kernel32, IUser32 user32, JoinableTaskFactory joinableTaskFactory)
    {
        _logger = logger;
        _kernel32 = kernel32;
        _user32 = user32;
        _joinableTaskFactory = joinableTaskFactory;
    }

    private static DateTime s_lastCheck;
    private static nint s_tarkWindow;

    private static readonly Dictionary<IntPtr, string> s_windowNameCache = new();

    private static readonly string[] s_windowNames = { "EscapeFromTarkov" };
    private readonly ILogger<NativeMethods> _logger;
    private readonly IKernel32 _kernel32;
    private readonly IUser32 _user32;
    private readonly JoinableTaskFactory _joinableTaskFactory;

    public bool IsTarkovInForeground() => _user32.WindowForegrounding.GetForegroundWindow() == GetTarkovWindow();

    public nint GetTarkovWindow()
    {
        if (DateTime.Now - s_lastCheck < new TimeSpan(0, 0, 5) && s_tarkWindow == IntPtr.Zero)
        {
            return IntPtr.Zero;
        }

        if (s_tarkWindow != IntPtr.Zero)
        {
            if (_user32.IsWindow(s_tarkWindow))
            {
                return s_tarkWindow;
            }

            s_tarkWindow = IntPtr.Zero;
            s_windowNameCache.Clear();
        }

        s_tarkWindow = _user32.FindWindow("UnityWndClass", "EscapeFromTarkov");

        if (s_tarkWindow != IntPtr.Zero)
        {
            return s_tarkWindow;
        }

        foreach (string? windowName in s_windowNames)
        {
            s_tarkWindow = _user32.FindWindow("UnityWndClass", windowName);
            if (s_tarkWindow == IntPtr.Zero)
            {
                continue;
            }

            break;
        }

        s_lastCheck = DateTime.Now;
        return s_tarkWindow;
    }

    public uint GetTarkovProcId() => s_tarkWindow == IntPtr.Zero ? 0 : _user32.GetWindowThreadProcessId(s_tarkWindow).processId;

    public async Task BringTarkovToForegroundAsync()
    {
        nint tHandle = GetTarkovWindow();
        if (tHandle == IntPtr.Zero)
        {
            return;
        }

        await _joinableTaskFactory.SwitchToMainThreadAsync();

        ForceWindowIntoForeground((HWND)tHandle);
    }

    public void FlashTarkov() => _user32.FlashWindow(GetTarkovWindow(), false);

    public string GetProcessFilename(uint processId)
    {
        System.Runtime.InteropServices.SafeHandle? handle = _kernel32.OpenProcess(false, processId);
        return _kernel32.QueryFullProcessImageName(handle);
    }

    public unsafe void ForceWindowIntoForeground(HWND window)
    {
        uint currentThread = _kernel32.GetCurrentThreadId();

        nint activeWindow = _user32.WindowForegrounding.GetForegroundWindow();

        (uint activeThread, _) = _user32.GetWindowThreadProcessId(activeWindow);
        (uint windowThread, _) = _user32.GetWindowThreadProcessId(window);

        if (currentThread != activeThread)
            _user32.AttachThreadInput(currentThread, activeThread, true);
        if (windowThread != currentThread)
            _user32.AttachThreadInput(windowThread, currentThread, true);

        uint oldTimeout = _user32.SystemParametersInfo.GetForegroundLockTimeout();
        _user32.SystemParametersInfo.SetForegroundLockTimeout(0);
        _user32.WindowForegrounding.SetForegroundWindowUnlock();
        _user32.WindowForegrounding.AllowSetForegroundWindow();
        
        _user32.WindowForegrounding.SetForegroundWindow(window);
        _user32.ShowWindow(window, Windows.Win32.UI.WindowsAndMessaging.SHOW_WINDOW_CMD.SW_RESTORE);

        _user32.SystemParametersInfo.SetForegroundLockTimeout(oldTimeout);

        if (currentThread != activeThread)
            _user32.AttachThreadInput(currentThread, activeThread, false);
        if (windowThread != currentThread)
            _user32.AttachThreadInput(windowThread, currentThread, false);
    }
}
