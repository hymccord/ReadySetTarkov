using System;
using System.Collections.Generic;

namespace ReadySetTarkov.Utility
{
    /// <summary>
    /// PInvoke area. See NativeMethods.txt for methods that are beingn generated by CsWin32.
    /// </summary>
    public class NativeMethods : INativeMethods
    {
        public NativeMethods(IKernel32 kernel32, IUser32 user32)
        {
            _kernel32 = kernel32;
            _user32 = user32;
        }

        private static DateTime s_lastCheck;
        private static nint s_tarkWindow;

        private static readonly Dictionary<IntPtr, string> s_windowNameCache = new();

        private static readonly string[] s_windowNames = { "EscapeFromTarkov" };
        private readonly IKernel32 _kernel32;
        private readonly IUser32 _user32;

        public bool IsTarkovInForeground() => _user32.GetForegroundWindow() == GetTarkovWindow();

        public nint GetTarkovWindow()
        {
            if (DateTime.Now - s_lastCheck < new TimeSpan(0, 0, 5) && s_tarkWindow == IntPtr.Zero)
            {
                return IntPtr.Zero;
            }

            if (s_tarkWindow != IntPtr.Zero)
            {
                if (_user32.IsWindow(s_tarkWindow))
                {
                    return s_tarkWindow;
                }

                s_tarkWindow = IntPtr.Zero;
                s_windowNameCache.Clear();
            }

            s_tarkWindow = _user32.FindWindow("UnityWndClass", "EscapeFromTarkov");

            if (s_tarkWindow != IntPtr.Zero)
            {
                return s_tarkWindow;
            }

            foreach (var windowName in s_windowNames)
            {
                s_tarkWindow = _user32.FindWindow("UnityWndClass", windowName);
                if (s_tarkWindow == IntPtr.Zero)
                {
                    continue;
                }

                break;
            }

            s_lastCheck = DateTime.Now;
            return s_tarkWindow;
        }

        public uint GetTarkovProcId()
        {
            if (s_tarkWindow == IntPtr.Zero)
            {
                return 0;
            }

            return _user32.GetWindowThreadProcessId(s_tarkWindow);
        }

        private static readonly nint HWND_TOPMOST = new IntPtr(-1);
        private static readonly nint HWND_NOTOPMOST = new IntPtr(-2);
        private const uint SWP_NOSIZE = 0x0001;
        private const uint SWP_NOMOVE = 0x0002;
        private const uint TOPMOST_FLAGS = SWP_NOMOVE | SWP_NOSIZE;
        public void BringTarkovToForeground()
        {
            var tHandle = GetTarkovWindow();
            if (tHandle == IntPtr.Zero)
            {
                return;
            }

            _user32.SetWindowPos(tHandle, HWND_TOPMOST, 0, 0, 0, 0, TOPMOST_FLAGS);
            _user32.SetWindowPos(tHandle, HWND_NOTOPMOST, 0, 0, 0, 0, TOPMOST_FLAGS);
            _user32.SetForegroundWindow(tHandle);
            _user32.SetFocus(tHandle);
            _user32.SetActiveWindow(tHandle);
        }

        public void FlashTarkov() => _user32.FlashWindow(GetTarkovWindow(), false);

        public string GetProcessFilename(uint processId)
        {
            var handle = _kernel32.OpenProcess(false, processId);
            return _kernel32.QueryFullProcessImageName(handle);
        }
    }
}
